<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>AngularJS Best Practices</title><meta name="description" content="A framework for easily creating beautiful presentations using HTML"><meta name="author" content="Hakim El Hattab"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"><link rel="stylesheet" href="css/reveal.css"><link id="theme" rel="stylesheet" href="css/theme/black.css"><link rel="stylesheet" href="css/custom.css"><!-- Code syntax highlighting--><link rel="stylesheet" href="lib/css/zenburn.css"><link rel="stylesheet" href="lib/font/font-awesome/css/font-awesome.min.css"><!-- Printing and PDF exports--><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );</script><!--if lt IE 9script(src='lib/js/html5shiv.js')--></head><body><img id="logo-h5t" src="assets/logoH5T.png"><img id="logo-vroom" src="assets/logoVroom.png"><img id="flag" src="assets/flag.svg"><div class="reveal"><!-- Any section element inside of this container is displayed as a slide--><div class="slides"><!--INTRO--><section><img src="assets/angularjs-logo.png" class="no-default"><h1>AngularJS<br>Best Practices</h1><h3>GDG DevFest Mediterranean 2015</h3><p><small>Francesco Sciuti / Stefano Torresi</small></p></section><section><h2>Chi sono questi due?</h2><p>Difficile da dire senza usare brutte parole...<br>beh, siamo amanti e professionisti del web! Penso che basti!</p><aside class="notes">[Qui note di presentazione]</aside></section><section><h2>Perchè Best Practices?</h2>L'utilizzo delle Best Practices aiuta a scrivere codice migliore, facilmente riutilizzabile ed in minor tempo.<p>Parleremo di:</p><ul><li>Scaffolding</li><li>Architettura</li><li>Templates</li></ul><aside class="notes">[Qui note di presentazione]</aside></section><!-- SCAFFOLDING--><section><section><h2 class="yellow">Scaffolding</h2><p>Strutturare un'<em>App Angular&nbsp;</em>e scegliere gli strumenti per evitare di impazzire dopo poco tempo!</p><small>Nelle prime fasi di un progetto si trascurano questi aspetti ma nel lungo termine influenzerenno il codice e la manutenibilit&agrave.<br>Tutto ciò che serve è un po 'di accortezza, un po' di disciplina e una banale preferenza per la sanità mentale, piuttosto che la pazzia.</small><aside class="notes">Ci sono molti modi per strutturare un app e noi provvederemo a prendere in prestito alcuni principi da soluzioni consolidate, oltre ad alcune metodologie specifiche per Angular.</aside></section><!-- SCAFFOLDING - STRUTTURA--><section><h3 class="yellow">Scaffolding - Struttura di un'App</h3><h4>Folders-by-Type vs Folders-by-Feature</h4><p>Usare un approccio Folders-by-Feature piuttosto che il classico approccio Folders-by-Type</p><aside class="notes">[Qui note di presentazione]</aside></section><section><h3 class="yellow">Scaffolding - Struttura di un'App</h3><h4><i class="fa fa-close fa-red"></i>Folders-by-Type</h4><small>Approccio<em>&nbsp;MVC&nbsp;</em>(cartelle controllers, viste, direttive, etc..)</small><small><em><strong>Perchè no?</strong><br>Al crescere del progetto la struttura risulta dispersiva, e non consente di rintracciare facilmente le risorse del progetto, oltre che scomode da rendere riutilizzabili.</em></small><hr><h4><i class="fa fa-check fa-green"></i>Folders-by-Feature</h4><small>L'approccio&nbsp;<em>Folders-by-Feature</em> invece organizza i files per&nbsp;<em>funzionalità</em></small><small><em><strong>Perchè si?</strong><br>La struttura risulta quindi modulare!<br>Lo sviluppatore può rintracciare facilmente il codice ed identificare ciò che rappresenta a colpo d'occhio.
La struttura inoltre è piatta e non c'è ripetitività o nomi ridondanti.</em></small><aside class="notes">[Qui note di presentazione]</aside></section><section><h3 class="yellow">Scaffolding - Struttura di un'App</h3><table style="width:100%"><tr><td><h4><i class="fa fa-close fa-red"></i>Folders-by-Type</h4><pre class="no-default nohighlight"><code>app/
  app.module.js
  app.config.js
  app.routes.js
  directives.js
  controllers/
      blog.js
      shell.js
      user.js
      topnav.js
  directives/
      calendar.directive.js
      calendar.directive.html
      avatar.directive.js
      avatar.directive.html
  services/
      dataservice.js
      localstorage.js
  views/
      blog.html
      user.html
      sessions.html
      shell.html
      ...</code></pre></td><td><h4><i class="fa fa-check fa-green"></i>Folders-by-Feature</h4><pre class="no-default nohighlight"><code>app/
  app.module.js
  app.config.js
  app.routes.js
  components/
      calendar.directive.js
      calendar.directive.html
      avatar.directive.js
      avatar.directive.html
  layout/
      shell.html
      shell.controller.js
      ...
  blog/
      blog.html
      blog.controller.js
  services/
      data.service.js
      localstorage.service.js
  user/
      user.html
      user.controller.js</code></pre></td></tr></table></section><!-- END SCAFFOLDING - STRUTTURA--><!-- SCAFFOLDING - NOMENCLATURA--><section><h3 class="yellow">Scaffolding - Nomenclatura</h3><h4>La regola fondamentale è la consistenza!</h4><p>Le convezioni sui nomi (sia dei files che dei componenti di AngularJS) consentono di organizzare bene un progetto, rendendo facile la rintracciabilità e la redazione del codice.</p></section><section><h3 class="yellow">Scaffolding - Nomenclatura</h3><h4><i class="fa fa-check fa-green"></i>Nomi dei files</h4><p>Lo schema suggerito &egrave:&nbsp;<em>feature.type.js</em>e per i test &egrave:&nbsp;<em>feature.type.spec.js</em></p><small><em><strong>Perchè si?</strong><br>Seguire uno schema nell'assegnazione dei nomi dei files consente di individuare a colpo d'occhio la funzionalità ed il tipo di codice contenuto in ogni singolo file.<br>Uno schema aiuta inoltre a gestire i processi di automazione (testing, concatenamento, minificazione, etc...).</em></small><pre class="no-default nohighlight half-width"><code>calendar.directive.js
calendar.directive.spec.js
shell.controller.js
shell.controller.spec.js
blog.controller.js
blog.controller.spec.js
data.service.js
data.service.spec.js</code></pre></section><section><h3 class="yellow">Scaffolding - Nomenclatura</h3><h4><i class="fa fa-check fa-green"></i>Nomi dei componenti di AngularJS</h4><small><table><thead><th>Componente</th><th>Convenzione</th><th>Esempio</th><th>Note</th></thead><tbody><tr><td>Controllers</td><td>camelCase</td><td><code>vrBlogsController</code></td><td>Suffisso &nbsp;<em>Controller</em></td></tr><tr><td>Services/Factories</td><td>camelCase</td><td><code>vrDataService</code></td><td>Suffisso &nbsp;<em>Service</em><br>Evitare il prefisso &nbsp;<em>$</em></td></tr><tr><td>Directives</td><td>camelCase</td><td><code>vrCalendarDirective</code></td><td>Suffisso &nbsp;<em>Directive</em></td></tr></tbody></table><p><small>N.B. Usa un breve prefisso minuscolo che descriva l'area alla quale la directive appartiene (alcuni esempi sono prefissi relativi all'azienda o al progetto).</small></p><em><strong>Perchè si?</strong><br>Seguire le convenzioni aiuta ad identificare facilmente e referenziare i componenti,<br>oltre che ad evitare eventuali collisioni di nomi.</em></small><pre class="no-default nohighlight half-width"><code>angular
  .module
  .controller('vrBlogsController', BlogsController);

  function BlogsController() {}</code></pre><aside class="notes">La nomenclatura di Papa cambia per l'uso del prefisso solo per le direttive, oltre che per la forma ed i suffissi.</aside></section><!-- END SCAFFOLDING - NOMENCLATURA--><!-- SCAFFOLDING - PACKAGE MANAGER--><section><h3 class="yellow">Scaffolding - Package Manager</h3><h4>npm & Bower</h4><p>Non possiamo fare a meno di un Package Manager!</p><img src="assets/bower-npm-logo.png" class="half-width"><aside class="notes">[Qui note di presentazione]</aside></section><section><h3 class="yellow">Scaffolding - Package Manager</h3><h4><i class="fa fa-check fa-green"></i>NPM</h4><p>Comunemente usato per la gestione di moduli Node.js, ma funziona bene anche per il front-end.</p><h4><i class="fa fa-check fa-green"></i>Bower</h4><p>Creato esclusivamente per il front-end ed è ottimizzato per questo scopo.</p><small><em><br>La più grande differenza è che&nbsp;<strong>NPM&nbsp;</strong>gestisce le dipendenze annidate mentre&nbsp;<strong>Bower&nbsp;</strong>richiede un albero delle dipendenze piatto.<br>La ragione per cui molti progetti usano entrambi è che usano&nbsp;<strong>Bower&nbsp;</strong>per i pacchetti di front-end e&nbsp;<strong>NPM&nbsp;</strong>per strumenti di sviluppo come&nbsp;<strong>Yeoman, Grunt, Gulp, JSHint, CoffeeScript, etc.</strong></em></small><aside class="notes"><p>Un albero delle dipendenze nidificato significa che le dipendenze possono avere le proprie dipendenze che possono avere il proprio, e così via. Esso consente di preoccuparsi di conflitti di dipendenza come tutte le dipendenze utilizzano ad esempio la propria versione di sottolineatura.</p></aside></section><!-- END SCAFFOLDING - PACKAGE MANAGER--><!-- SCAFFOLDING - TASK RUNNER--><section><h3 class="yellow">Scaffolding - Task Runner</h3><h4>Gulp vs Grunt</h4><p>Facciamo fare il lavoro ripetitivo ad altri!</p><img src="assets/build-tools.png"><aside class="notes">[Qui note di presentazione]</aside></section><section><h3 class="yellow">Scaffolding - Task Runner</h3><h4><i class="fa fa-check fa-green"></i>Gulp</h4><p>Gulp è&nbsp;<em>stream-based</em>, e lancia i processi in maniera&nbsp;<em>concorrente</em> in modo da eseguirli in parallelo, se possibile.</p><h4><i class="fa fa-close fa-red"></i>Grunt</h4><p>Grunt è&nbsp;<em>configuration-based</em>, e lancia i processi in maniera&nbsp;<em>sequenziale.</em></p><small><em><br>Da&nbsp;<strong>Grunt&nbsp;</strong>si passa a<strong>Gulp&nbsp;</strong>e non si torna indietro.<br>Pi&ugrave; veloce nell'esecuzione dei tasks, oltre che una migliore e flessibile modalit&agrave; di configurazione.</em></small><aside class="notes"><p>Vale la pena sottolineare che vi è una nuova versione del Grunt in sviluppo ed userà Orchestrator.</p></aside></section><!-- END SCAFFOLDING - TASK RUNNER--><!-- SCAFFOLDING - TASK RUNNER--><section><h3 class="yellow">Scaffolding - HTML Templates</h3><h4>Jade</h4><p>Un linguaggio per la scrittura concisa di template HTML.</p><img src="assets/jade-logo-header.svg" class="half-width"><aside class="notes">[Qui note di presentazione]</aside></section><!-- END SCAFFOLDING - TASK RUNNER--></section><!-- ARCHITETTURA--><section><section><h2 class="yellow">2 - ARCHITETTURA</h2><p>L'architettura di un'<em>Applicazione Angular&nbsp;</em>va studiata attentamente per realizzare progetti prestanti e solidi.</p><small>Conoscere l'anatomia dei componenti, curare attentamente il binding, conoscere la controller communication, etc...<br>ci aiuta ad ottimizzare ogni singola parte del nostro progetto.</small><aside class="notes">[Qui note di presentazione]</aside></section><!-- ARCHITETTURA - TIPS--><section><h3 class="yellow">2.1 - Tips Generali</h3><ul><li><h5>Responsabilità Singola<small>Definire un componente per singolo file.</small></h5></li><li><h5>IIEF<small>La<em>&nbsp;Immediately Invoked Function Expression&nbsp;</em>rimuove le variabili globali dallo scope.</small></h5></li><li><h5>Named Function<small>Usa funzioni che hanno un nome piuttosto che passare una funzione anonima nella dichiarazione dei componenti.</small></h5></li></ul><pre class="no-default nohighlight half-width"><code>(function() {
    'use strict';

    angular
        .module('app')
        .factory('storage', storage);

    function storage() { }
})();</code></pre><aside class="notes">[Qui note di presentazione]</aside></section><!-- END ARCHITETTURA - TIPS--><!-- ARCHITETTURA - MODULES--><!--section

  h3.yellow 2.1 - Moduli
  h4
  p
    | Conoscere bene i Moduli consente di avere dei
    em &nbsp;mattoni&nbsp;
    | riutilizzabili e facilmente testabili per le nostre Applicazioni.
  aside.notes
    | [Qui note di presentazione]--><section><h3 class="yellow">2.1 - Moduli</h3><ul><li><h5>Moduli piccoli ed autonomi<small>Ogni singolo modulo si occupa di una singola responsabilità.</small></h5></li><li><h5>Modulo principale per l'App<small>Modulo il cui ruolo è mettere insieme tutti i moduli le funzionalità dell'Applicazione. Comunemente assegnamo il nome<em>&nbsp;app.</em></small></h5></li><li><h5>Moduli usati come dipendenze<small>unemente assegnamo un nome che aiuti a definire la gerarchia dei moduli all'interno dell'Applicazione, esempio<em>&nbsp;app.blog</em></small></h5></li><li><h5>Usare Setter/Getter<small>Dichiarare i moduli usando la sintassi Setter (e non usando delle variabili) e recuperarli da lì in avanti via sintassi Getter</small></h5></li></ul><aside class="notes">[Qui note di presentazione]</aside></section><section><h3 class="yellow">2.1 - Moduli</h3><pre class="no-default nohighlight half-width"><code>//Modulo Principale
angular
  .module('app', [
    'ngAnimate',
    'ngRoute',
    'app.blog',
    'app.user'
]);

//Moduli Dipendenze
angular.module('app.blog', []);

angular.module('storage', []);</code></pre><aside class="notes">[Qui note di presentazione]</aside></section><!-- END ARCHITETTURA - MODULES--><!-- ARCHITETTURA - CONTROLLERS--><section><h3 class="yellow">2.1 - Controllers</h3><small><table style="width:100%"><tr><td><h5>Sintassi controllerAs</h5></td><td>Ogni singolo modulo si occupa di una singola responsabilità.</td><td></td></tr><tr><td><h5>Un Controller per Vista</h5></td><td>Modulo il cui ruolo è mettere insieme tutti i moduli le funzionalità dell'Applicazione. Comunemente assegnamo il nome<em>&nbsp;app.</em></td></tr><tr><td><h5>Controller dichiarati nelle Routes</h5></td><td>Comunemente assegnamo un nome che aiuti a definire la gerarchia dei moduli all'interno dell'Applicazione, esempio<em>&nbsp;app.blog</em></td></tr><tr><td><h5>Usare Setter/Getter</h5></td><td>Dichiarare i moduli usando la sintassi Setter (e non usando delle variabili) e recuperarli da lì in avanti via sintassi Getter</td></tr></table></small><pre class="no-default nohighlight half-width"><code>//Modulo Principale
angular
  .module('app', [
    'ngAnimate',
    'ngRoute',
    'app.blog',
    'app.user'
]);

//Moduli Dipendenze
angular.module('app.blog', []);
angular.module('storage', []);</code></pre><aside class="notes">[Qui note di presentazione]</aside></section><!-- END ARCHITETTURA - MODULES--><!-- ARCHITETTURA - SERVICES--><section><h3 class="yellow">2.3 - Servizi/Factory</h3><h4></h4><p>Usare un approccio Folders-by-Feature piuttosto che il classico approccio Folders-by-Type</p><aside class="notes">[Qui note di presentazione]</aside></section><section><h3 class="yellow">2.3 - Servizi/Factory</h3><h4><i class="fa fa-close fa-red"></i>Folders-by-Type</h4><p>Molti progetti AngularJS mostrano una struttura ispirata da un approccio<em>MVC</em>, organizzando quindi i files con un approccio di<em>Folders-by-Type&nbsp;</em>e cioè suddividendo le cartelle per controllers, viste, direttive, etc..</p><small><em><strong>Perchè no?</strong><br>Al crescere del progetto la struttura risulta dispersiva, e non consente di rintracciare facilmente le risorse del progetto, oltre che scomode da rendere riutilizzabili.</em></small><aside class="notes">[Qui note di presentazione]</aside></section><!-- END ARCHITETTURA - SERVICES--><!-- ARCHITETTURA - DIRETTIVE--><section><h3 class="yellow">2.4 - Direttive</h3><h4></h4><p>Usare un approccio Folders-by-Feature piuttosto che il classico approccio Folders-by-Type</p><aside class="notes">[Qui note di presentazione]</aside></section><section><h3 class="yellow">2.4 - Direttive</h3><h4><i class="fa fa-close fa-red"></i>Folders-by-Type</h4><p>Molti progetti AngularJS mostrano una struttura ispirata da un approccio<em>MVC</em>, organizzando quindi i files con un approccio di<em>Folders-by-Type&nbsp;</em>e cioè suddividendo le cartelle per controllers, viste, direttive, etc..</p><small><em><strong>Perchè no?</strong><br>Al crescere del progetto la struttura risulta dispersiva, e non consente di rintracciare facilmente le risorse del progetto, oltre che scomode da rendere riutilizzabili.</em></small><aside class="notes">[Qui note di presentazione]</aside></section><!-- END ARCHITETTURA - DIRETTIVE--><!-- ARCHITETTURA - SCOPE--><section><h3 class="yellow">2.5 - Scope</h3><h4></h4><p>Usare un approccio Folders-by-Feature piuttosto che il classico approccio Folders-by-Type</p><aside class="notes">[Qui note di presentazione]</aside></section><section><h3 class="yellow">2.5 - Scope</h3><h4><i class="fa fa-close fa-red"></i>Folders-by-Type</h4><p>Molti progetti AngularJS mostrano una struttura ispirata da un approccio<em>MVC</em>, organizzando quindi i files con un approccio di<em>Folders-by-Type&nbsp;</em>e cioè suddividendo le cartelle per controllers, viste, direttive, etc..</p><small><em><strong>Perchè no?</strong><br>Al crescere del progetto la struttura risulta dispersiva, e non consente di rintracciare facilmente le risorse del progetto, oltre che scomode da rendere riutilizzabili.</em></small><aside class="notes">[Qui note di presentazione]</aside></section><!-- END ARCHITETTURA - SCOPE--><!-- ARCHITETTURA - CROSS COMMUNICATION--><section><h3 class="yellow">2.6 - Controller Cross Communication</h3><h4></h4><p>Usare un approccio Folders-by-Feature piuttosto che il classico approccio Folders-by-Type</p><aside class="notes">[Qui note di presentazione]</aside></section><section><h3 class="yellow">2.6 - Controller Cross Communication</h3><h4><i class="fa fa-close fa-red"></i>Folders-by-Type</h4><p>Molti progetti AngularJS mostrano una struttura ispirata da un approccio<em>MVC</em>, organizzando quindi i files con un approccio di<em>Folders-by-Type&nbsp;</em>e cioè suddividendo le cartelle per controllers, viste, direttive, etc..</p><small><em><strong>Perchè no?</strong><br>Al crescere del progetto la struttura risulta dispersiva, e non consente di rintracciare facilmente le risorse del progetto, oltre che scomode da rendere riutilizzabili.</em></small><aside class="notes">[Qui note di presentazione]</aside></section><!-- END ARCHITETTURA - CROSS COMMUNICATION--></section><!-- TIPS--><section><section><h2 class="yellow">3 - Tips</h2><p>Strutturare un'<em>App Angular&nbsp;</em>e scegliere gli strumenti per evitare di impazzire dopo poco tempo!</p><small>Nelle prime fasi di un progetto si trascurano questi aspetti ma nel lungo termine influenzerenno il codice e la manutenibilit&agrave.<br>Tutto ciò che serve è un po 'di accortezza, un po' di disciplina e una banale preferenza per la sanità mentale, piuttosto che la pazzia.</small><aside class="notes">Ci sono molti modi per strutturare un app e noi provvederemo a prendere in prestito alcuni principi da soluzioni consolidate, oltre ad alcune metodologie specifiche per Angular.</aside></section></section><!-- END--><section><section><h2>Riepilogo BP</h2><table><thead><tr><th>Item</th><th>Value</th><th>Quantity</th></tr></thead><tbody><tr><td>Apples</td><td>$1</td><td>7</td></tr><tr></tr><tr><td>Lemonade</td><td>$2</td><td>18</td></tr><tr></tr><tr><td>Bread</td><td>$3</td><td>2</td></tr><tr></tr></tbody></table></section><section><h2>Giuramento</h2><p>These guys come in two forms, inline:<q cite="http://searchservervirtualization.techtarget.com/definition/Our-Favorite-Technology-Quotations">“The nice thing about standards is that there are so many to choose from”</q> and block:</p><blockquote cite="http://searchservervirtualization.techtarget.com/definition/Our-Favorite-Technology-Quotations">“For years there has been a theory that millions of monkeys typing at random on millions of typewriters would
reproduce the entire works of Shakespeare. The Internet has proven this theory to be untrue.”</blockquote></section><section data-state="no-logos"><h1>THE END</h1><p>Francesco Sciuti / Stefano Torresi</p><p><img src="assets/logoH5T.png" class="no-default"><br><small>http://www.html5today.it</small></p><p><img src="assets/logoVroom.png" class="no-default"><br><small>http://vroom.agency</small></p></section></section></div></div><script src="lib/js/head.min.js"></script><script src="js/reveal.js"></script><script>// Full list of configuration options available at:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({
controls: true,
progress: true,
history: true,
center: true,
mouseWheel: true,
transition: 'slide', // none/fade/slide/convex/concave/zoom
// Optional reveal.js plugins
dependencies: [
{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
{ src: 'plugin/zoom-js/zoom.js', async: true },
{ src: 'plugin/notes/notes.js', async: true }
]
});</script></body></html>